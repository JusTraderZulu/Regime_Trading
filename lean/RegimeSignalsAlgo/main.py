# region imports
from AlgorithmImports import *
# endregion

class RegimeSignalsAlgo(QCAlgorithm):
    """
    QuantConnect algorithm that reads regime signals from CSV and executes accordingly.
    Signals are generated by the LangGraph pipeline (src/agents/).
    """
    
    def Initialize(self):
        """Initialize algorithm parameters and data subscriptions"""
        
        # Set dates from config (can be overridden by CLI)
        self.SetStartDate(2015, 1, 1)
        self.SetEndDate(2025, 1, 1)
        
        # Starting cash
        self.SetCash(100000)
        
        # Universe of assets (from company config)
        self.crypto_symbols = ["BTCUSD", "ETHUSD"]
        self.fx_symbols = ["EURUSD", "GBPUSD", "USDJPY"]
        
        # Subscribe to crypto (using Coinbase/GDAX)
        for symbol in self.crypto_symbols:
            self.AddCrypto(symbol, Resolution.Hour, Market.GDAX)
        
        # Subscribe to FX (using Oanda)
        for symbol in self.fx_symbols:
            try:
                self.AddForex(symbol, Resolution.Hour, Market.Oanda)
            except:
                self.Debug(f"Could not add {symbol}")
        
        # Add custom signals data source
        # Points to: data/alternative/my_signals/signals.csv
        self.signals_symbol = self.AddData(
            SignalsRow,
            "my_signals/signals",  # Path relative to data/alternative/
            Resolution.Hour
        ).Symbol
        
        # Portfolio construction
        self.target_vol = 0.12  # 12% annualized target volatility
        self.positions = {}  # Track current positions
        
        # Risk management
        self.max_drawdown_threshold = 0.18  # Circuit breaker at 18% DD
        self.initial_portfolio_value = self.Portfolio.TotalPortfolioValue
        self.peak_value = self.initial_portfolio_value
        
        self.Debug("RegimeSignalsAlgo initialized")
        self.Debug(f"Signals path: data/alternative/my_signals/signals.csv")
    
    def OnData(self, data: Slice):
        """Process incoming data and signals"""
        
        # Check for new signals
        if self.signals_symbol in data:
            signal = data[self.signals_symbol]
            self.ProcessSignal(signal)
        
        # Update risk management
        self.UpdateRiskManagement()
    
    def ProcessSignal(self, signal):
        """
        Process a signal row and generate trading insights.
        
        Args:
            signal: SignalsRow custom data object
        """
        symbol_str = signal.Symbol
        regime = signal.Regime
        side = signal.Side
        weight = signal.Weight
        confidence = signal.Confidence
        
        self.Debug(
            f"Signal: {symbol_str} | Regime={regime} | "
            f"Side={side} | Weight={weight:.2f} | Conf={confidence:.2f}"
        )
        
        # Map symbol string to QC Symbol
        try:
            if symbol_str in self.crypto_symbols:
                qc_symbol = self.Symbol(symbol_str)
            elif symbol_str in self.fx_symbols:
                qc_symbol = self.Symbol(symbol_str)
            else:
                self.Debug(f"Unknown symbol: {symbol_str}")
                return
        except Exception as e:
            self.Debug(f"Error mapping symbol {symbol_str}: {e}")
            return
        
        # Calculate target position size
        target_pct = side * weight  # -1 to 1 range
        
        # Scale by confidence (optional)
        target_pct *= confidence
        
        # Apply target volatility scaling (simplified)
        # In production, use realized volatility
        current_price = self.Securities[qc_symbol].Price
        if current_price > 0:
            self.SetHoldings(qc_symbol, target_pct)
            self.positions[qc_symbol] = target_pct
    
    def UpdateRiskManagement(self):
        """Update portfolio risk management and circuit breakers"""
        
        current_value = self.Portfolio.TotalPortfolioValue
        
        # Update peak
        if current_value > self.peak_value:
            self.peak_value = current_value
        
        # Calculate drawdown
        if self.peak_value > 0:
            drawdown = (self.peak_value - current_value) / self.peak_value
            
            # Circuit breaker
            if drawdown > self.max_drawdown_threshold:
                self.Debug(f"CIRCUIT BREAKER: DD={drawdown:.2%} > {self.max_drawdown_threshold:.2%}")
                self.Liquidate()
                self.Quit("Max drawdown exceeded")


class SignalsRow(PythonData):
    """
    Custom data class for reading signals CSV.
    Maps to the exact format produced by src/bridges/signals_writer.py
    """
    
    def GetSource(self, config, date, isLiveMode):
        """Return the source URL/path for signals data"""
        
        if isLiveMode:
            # In live mode, could fetch from HTTPS endpoint
            # For now, use local file
            return SubscriptionDataSource(
                "data/alternative/my_signals/signals.csv",
                SubscriptionTransportMedium.LocalFile
            )
        else:
            # Backtest mode: local file
            return SubscriptionDataSource(
                "data/alternative/my_signals/signals.csv",
                SubscriptionTransportMedium.LocalFile
            )
    
    def Reader(self, config, line, date, isLiveMode):
        """Parse a line from the signals CSV"""
        
        if not (line.strip() and line[0].isdigit()):
            # Skip header or empty lines
            return None
        
        signal = SignalsRow()
        signal.Symbol = config.Symbol
        
        try:
            # Parse CSV: time,symbol,asset_class,venue,regime,side,weight,confidence,mid,...
            parts = line.split(',')
            
            if len(parts) < 8:
                return None
            
            # Extract fields
            signal.Time = datetime.strptime(parts[0], "%Y-%m-%dT%H:%M:%SZ")
            signal.Symbol = parts[1]  # Override with actual symbol
            signal.AssetClass = parts[2]
            signal.Venue = parts[3]
            signal.Regime = parts[4]
            signal.Side = int(parts[5])
            signal.Weight = float(parts[6])
            signal.Confidence = float(parts[7])
            
            # Optional fields
            signal.Mid = float(parts[8]) if parts[8] else 0.0
            signal.Spread = float(parts[9]) if len(parts) > 9 and parts[9] else 0.0
            
            # Set Value (required by QC)
            signal.Value = signal.Side * signal.Weight
            
            return signal
            
        except Exception as e:
            # Log parse errors
            return None


# Placeholder for portfolio models (to be implemented)
class TargetVolPortfolio:
    """
    Portfolio construction model targeting specific volatility.
    TODO: Implement proper vol scaling and position sizing.
    """
    pass

