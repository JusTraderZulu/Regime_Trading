#!/usr/bin/env python
"""
Generate a complete QC algorithm with embedded signals.
This creates a self-contained Python file that can be uploaded to QC.
"""

import json
import sys
from pathlib import Path
from datetime import datetime

# Add src to path
sys.path.insert(0, str(Path(__file__).parent.parent))

from src.bridges.signals_writer import read_signals_csv


ALGORITHM_TEMPLATE = '''# region imports
from AlgorithmImports import *
import json
# endregion

class RegimeSignalsAlgo(QCAlgorithm):
    """
    Regime-based trading algorithm with dynamic strategy execution.
    Signals generated by LangGraph pipeline on {generation_date}.
    
    Executes the optimal strategy selected for each detected regime.
    """
    
    def Initialize(self):
        self.SetStartDate(2025, 10, 1)
        self.SetEndDate(2025, 10, 31)
        self.SetCash(100000)
        
        # Subscribe to symbols from signals
        self.crypto_symbols = {crypto_symbols}
        for symbol in self.crypto_symbols:
            self.AddCrypto(symbol, Resolution.Hour, Market.GDAX)
        
        # Embedded signals data (includes strategy + params)
        self.signals_data = {signals_data}
        
        # Current active strategy per symbol
        self.active_strategies = {{}}  # symbol → {{'strategy': name, 'params': dict, 'regime': str}}
        
        # Portfolio settings
        self.target_vol = 0.12
        
        self.Debug(f"Initialized with {{len(self.signals_data)}} signals")
        
        # Process initial signals
        self.ProcessSignals()
    
    def ProcessSignals(self):
        """Process all signals and set up active strategies"""
        for signal in self.signals_data:
            symbol_str = signal['symbol']
            strategy_name = signal.get('strategy_name')
            strategy_params_str = signal.get('strategy_params')
            regime = signal['regime']
            
            if strategy_name and strategy_params_str:
                try:
                    params = json.loads(strategy_params_str)
                    self.active_strategies[symbol_str] = {{
                        'strategy': strategy_name,
                        'params': params,
                        'regime': regime,
                        'weight': signal['weight'],
                        'confidence': signal['confidence']
                    }}
                    self.Debug(f"Set strategy for {{symbol_str}}: {{strategy_name}} with params {{params}}")
                except Exception as e:
                    self.Debug(f"Error parsing strategy for {{symbol_str}}: {{e}}")
    
    def OnData(self, data):
        """Execute strategies based on signals"""
        
        for symbol_str in self.crypto_symbols:
            if symbol_str not in self.active_strategies:
                continue
            
            strategy_info = self.active_strategies[symbol_str]
            strategy_name = strategy_info['strategy']
            params = strategy_info['params']
            weight = strategy_info['weight']
            confidence = strategy_info['confidence']
            
            try:
                qc_symbol = Symbol.Create(symbol_str, SecurityType.Crypto, Market.GDAX)
                
                if qc_symbol not in data or not data[qc_symbol]:
                    continue
                
                # Execute the strategy
                signal = self.ExecuteStrategy(qc_symbol, strategy_name, params)
                
                if signal != 0:
                    # Scale by weight and confidence
                    target_pct = signal * weight * confidence
                    
                    if abs(target_pct) > 0.01:
                        self.SetHoldings(qc_symbol, target_pct)
                        self.Debug(f"{{strategy_name}}: {{symbol_str}} → {{target_pct:.2%}}")
                else:
                    self.Liquidate(qc_symbol)
                    
            except Exception as e:
                self.Debug(f"Error executing strategy for {{symbol_str}}: {{e}}")
    
    def ExecuteStrategy(self, symbol, strategy_name, params):
        """
        Execute a strategy and return signal (-1, 0, 1).
        
        Args:
            symbol: QC Symbol object
            strategy_name: Strategy name (ma_cross, rsi, etc.)
            params: Strategy parameters dict
        
        Returns:
            -1 (short), 0 (flat), 1 (long)
        """
        try:
            if strategy_name == 'ma_cross':
                return self.MACross(symbol, params)
            elif strategy_name == 'ema_cross':
                return self.EMACross(symbol, params)
            elif strategy_name == 'bollinger_revert':
                return self.BollingerRevert(symbol, params)
            elif strategy_name == 'rsi':
                return self.RSI(symbol, params)
            elif strategy_name == 'macd':
                return self.MACD(symbol, params)
            elif strategy_name == 'donchian':
                return self.Donchian(symbol, params)
            elif strategy_name == 'carry':
                return 1  # Always long
            else:
                self.Debug(f"Unknown strategy: {{strategy_name}}")
                return 0
        except Exception as e:
            self.Debug(f"Strategy {{strategy_name}} error: {{e}}")
            return 0
    
    # Strategy implementations
    def MACross(self, symbol, params):
        """MA Cross implementation"""
        fast = params.get('fast', 10)
        slow = params.get('slow', 30)
        
        history = self.History(symbol, slow + 5, Resolution.Hour)
        if history.empty:
            return 0
        
        closes = history['close']
        ma_fast = closes.rolling(fast).mean().iloc[-1]
        ma_slow = closes.rolling(slow).mean().iloc[-1]
        
        return 1 if ma_fast > ma_slow else -1
    
    def EMACross(self, symbol, params):
        """EMA Cross implementation"""
        fast = params.get('fast', 8)
        slow = params.get('slow', 21)
        
        history = self.History(symbol, slow + 5, Resolution.Hour)
        if history.empty:
            return 0
        
        closes = history['close']
        ema_fast = closes.ewm(span=fast, adjust=False).mean().iloc[-1]
        ema_slow = closes.ewm(span=slow, adjust=False).mean().iloc[-1]
        
        return 1 if ema_fast > ema_slow else -1
    
    def BollingerRevert(self, symbol, params):
        """Bollinger Bands implementation"""
        window = params.get('window', 20)
        num_std = params.get('num_std', 2.0)
        
        history = self.History(symbol, window + 5, Resolution.Hour)
        if history.empty:
            return 0
        
        closes = history['close']
        ma = closes.rolling(window).mean().iloc[-1]
        std = closes.rolling(window).std().iloc[-1]
        current = closes.iloc[-1]
        
        upper = ma + num_std * std
        lower = ma - num_std * std
        
        if current < lower:
            return 1
        elif current > upper:
            return -1
        return 0
    
    def RSI(self, symbol, params):
        """RSI implementation"""
        period = params.get('period', 14)
        oversold = params.get('oversold', 30)
        overbought = params.get('overbought', 70)
        
        history = self.History(symbol, period + 10, Resolution.Hour)
        if history.empty:
            return 0
        
        closes = history['close']
        delta = closes.diff()
        gain = delta.where(delta > 0, 0).rolling(period).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(period).mean()
        
        rs = gain / loss
        rsi = 100 - (100 / (1 + rs))
        current_rsi = rsi.iloc[-1]
        
        if current_rsi < oversold:
            return 1
        elif current_rsi > overbought:
            return -1
        return 0
    
    def MACD(self, symbol, params):
        """MACD implementation"""
        fast = params.get('fast', 12)
        slow = params.get('slow', 26)
        signal_pd = params.get('signal', 9)
        
        history = self.History(symbol, slow + signal_pd + 5, Resolution.Hour)
        if history.empty:
            return 0
        
        closes = history['close']
        ema_fast = closes.ewm(span=fast, adjust=False).mean()
        ema_slow = closes.ewm(span=slow, adjust=False).mean()
        macd = ema_fast - ema_slow
        macd_signal = macd.ewm(span=signal_pd, adjust=False).mean()
        
        return 1 if macd.iloc[-1] > macd_signal.iloc[-1] else -1
    
    def Donchian(self, symbol, params):
        """Donchian Channel implementation"""
        lookback = params.get('lookback', 20)
        
        history = self.History(symbol, lookback + 5, Resolution.Hour)
        if history.empty:
            return 0
        
        highs = history['high']
        lows = history['low']
        closes = history['close']
        
        upper = highs.rolling(lookback).max().iloc[-2]
        lower = lows.rolling(lookback).min().iloc[-2]
        current = closes.iloc[-1]
        
        if current >= upper:
            return 1
        elif current <= lower:
            return -1
        return 0
'''


def generate_algorithm(signals_csv_path: Path, output_path: Path):
    """
    Update QC algorithm with latest signals data.
    Only replaces the SIGNALS_DATA_PLACEHOLDER, keeping strategy code intact.
    
    Args:
        signals_csv_path: Path to signals CSV
        output_path: Path for output Python file
    """
    print(f"Reading signals from: {signals_csv_path}")
    
    # Read signals
    signals = read_signals_csv(signals_csv_path)
    print(f"✓ Loaded {len(signals)} signals")
    
    # Convert signals to embedded data (with strategy info!)
    signals_data = []
    for s in signals:
        signal_dict = {
            'time': s.time.strftime("%Y-%m-%dT%H:%M:%SZ"),
            'symbol': s.symbol,
            'regime': s.regime,
            'side': s.side,
            'weight': s.weight,
            'confidence': s.confidence,
        }
        
        # Add strategy info if available
        if s.strategy_name:
            signal_dict['strategy_name'] = s.strategy_name
            signal_dict['strategy_params'] = s.strategy_params or '{}'
        
        signals_data.append(signal_dict)
    
    # Read the template main.py
    template_path = Path(__file__).parent.parent / "lean" / "main.py"
    if not template_path.exists():
        print(f"ERROR: Template not found: {template_path}")
        return
    
    algorithm_code = template_path.read_text()
    
    # Replace the placeholder with actual data
    # Format as Python list assignment
    signals_data_str = json.dumps(signals_data, indent=4)
    
    # Replace the bottom placeholder (the variable assignment)
    algorithm_code = algorithm_code.replace(
        'SIGNALS_DATA_PLACEHOLDER = []',
        f'SIGNALS_DATA_PLACEHOLDER = {signals_data_str}'
    )
    
    # Write to file
    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text(algorithm_code)
    
    print(f"✓ Generated algorithm: {output_path}")
    print(f"  - Signals: {len(signals_data)}")
    
    # Show strategies
    strategies_used = set(s.get('strategy_name') for s in signals_data if s.get('strategy_name'))
    if strategies_used:
        print(f"  - Strategies: {', '.join(strategies_used)}")
    
    print()
    print("Next steps:")
    print(f"1. Open: https://www.quantconnect.com/terminal/24586010")
    print(f"2. Upload: {output_path} (and strategies_library.py if first time)")
    print("3. Click 'Build' then 'Backtest'")


if __name__ == "__main__":
    signals_path = Path("data/signals/latest/signals.csv")
    output_path = Path("lean/generated_algorithm.py")
    
    if not signals_path.exists():
        print(f"❌ Signals not found: {signals_path}")
        print("Generate signals first:")
        print("  python -m src.ui.cli run --symbol X:BTCUSD --mode thorough")
        sys.exit(1)
    
    generate_algorithm(signals_path, output_path)

